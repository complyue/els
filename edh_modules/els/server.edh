{##
 # shared Đ (Edh) language server
 #
 # LSP up to 3.15, assumes that one server serves one tool. No support in the
 # protocol to share one server between different tools.
 # Such a sharing would require additional protocol e.g. to lock a document to
 # support concurrent editing.
 #
 # ELS as implemented here assumes server sharing be possible, especially when
 # debugging the els server functionality, an els process would be started from
 # the command line before an els client embedded in a VSCode instance is
 # started.
 #}

import * 'net'

import * 'els/RT'


{##
 # the `start-els` executable (launched by VSCode on-demand e.g.) will connect
 # to starter service by an ELS, and issue `AttachToClient(<port>)` to request
 # a connection from this ELS to that socket based language server client, then
 # language service will be provided over that connection.
 #}
export data ELS (
  # local port & addr to accept connections from els starters
  c4aPort = 1707, c4aAddr = '127.0.0.1',
) {

  method __init__(*** _ ) {
    this.starter = Server(
      'els/start', # the starter service module
      this.c4aAddr, this.c4aPort,
      init= modu => { # per-connection peer module initialization
        # expose all exported methods of this els instance there,
        # to be rpcallable by els starters
        import * this into modu
      },
    )
    case this.starter.addrs() of {
      { elsAddr :>_ } -> console.info
      <| 'Đ (Edh) Language Server starter service listening: ' ++ elsAddr
      # or the network has failed, propagate the error
      this.starter.join() # this usually throws
      # in case join() didn't throw, report this error
      error( 'Đ (Edh) Language Server failed listening.' )
    }

  }


  method join() this.starter.join()

  {##
   # meant to be rpcalled by a `start-els` process launched from VSCode, who
   # connects to this ELS. this ELS could have been launched by that starter,
   # in case no other ELS instance already started to provide global language
   # service on the configured c4aPort/c4aAddr, which is the usual use case.
   #}
  export method AttachToClient(
    port,
    addr= '127.0.0.1', service= 'els/server',
  ) {
    cc = CC( service, port, addr )
    {
      case cc.addrs() of {
        { ccAddr :>_ } -> console.info
        <| 'Đ (Edh) Language Server connected to client: ' ++ ccAddr
        # or the network has failed, propagate the error
        cc.join() # this usually throws
        # in case join() didn't throw, report this error
        error( 'Đ (Edh) Language Server failed connecting to ' ++ port,
          addr=addr, service=service )
      }

      # successfully connected
      # TODO any special treatment for Initialize Request?
      # https://microsoft.github.io/language-server-protocol/specification#initialize

    } $=> { exc } -> {
      console.error<| 'Exception by els client connection '
      ++ cc ++ ' triggered by starter ' ++ perform @netPeer
      ++ ' error:\n  ' ++ desc( exc )

      # disconnect the client as well as the starter
      cc.stop()
      perform @disconnectPeer()
    }
  }

}
