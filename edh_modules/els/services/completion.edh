
import ( world, elsDebug, **_ ) 'els'

import * './utils'


data CompletionContext( triggerKind, triggerCharacter ) {

  Invoked = 1
  TriggerCharacter = 2
  TriggerForIncompleteCompletions = 3

  # this'll always match
  method __match__( jsonRepr ) return CompletionContext (
    jsonRepr[ 'triggerKind' ] or Invoked,
    jsonRepr[ 'triggerCharacter' ] or None,
  )

}


export method @'textDocument/completion' (
  textDocument, position, context= {}, ***_
) void {
  # try parse & resolve then obtain completion asynchronously,
  # to not block subsequent requests from the lsp client
  case textDocument of { TxtDocFile( absFilePath ) } ->
  case position of { Position( line, character ) } ->
  case context of { CompletionContext( triggerKind, triggerCharacter ) } ->
  { return { go {
        modu = world.locateByFile( absFilePath )
        perform lspRespond(
          world.suggest( modu, line, character )
        )
        # case triggerKind of {
        #   CompletionContext.TriggerCharacter -> case triggerCharacter of {
        #     '.' -> perform lspRespond(
        #       world.suggest( modu, line, character )
        #     )
        #     '@' -> perform lspRespond(
        #       world.suggest( modu, line, character )
        #     )
        #     error( 'unexpected trigger char: ' ++ triggerCharacter )
        #   }

        #   CompletionContext.Invoked -> perform lspRespond(
        #     world.suggest( modu, line, character )
        #   )

        #   CompletionContext.TriggerForIncompleteCompletions -> {
        #  # todo err out instead?
        #     perform lspRespond( world.suggest( modu, line, character ) )
        #   }

        #   error( 'unexpected trigger kind: ' ++ triggerKind )
        # }
  } } }
  error( 'unexpected lsp params' )
}
